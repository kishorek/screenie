<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen & Camera Recorder</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        .preview {
            position: relative;
            width: 100%;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            min-height: 400px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        #screenPreview {
            width: 100%;
            height: 100%;
            background-color: #000;
            object-fit: contain;
        }
        
        #cameraPreview {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background-color: #333;
            border: 3px solid #fff;
            overflow: hidden;
            cursor: move;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            top: 20px;
            right: 20px;
            z-index: 100;
            transition: all 0.3s ease;
        }
        
        #cameraPreview:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        
        #cameraPreview.dragging {
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
        }
        
        #cameraVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            background-color: #4285f4;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        button:hover {
            background-color: #3367d6;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        #recordButton {
            background-color: #ea4335;
        }
        
        #recordButton:hover {
            background-color: #d33426;
        }
        
        #stopButton {
            background-color: #fbbc05;
            color: #333;
        }
        
        #stopButton:hover {
            background-color: #f2b600;
        }
        
        .message {
            margin-top: 20px;
            padding: 12px 16px;
            border-radius: 6px;
            color: #3c763d;
            background-color: #dff0d8;
            border: 1px solid #d6e9c6;
            display: none;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #downloadContainer {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            animation: fadeIn 0.5s;
        }
        
        #downloadVideo {
            width: 100%;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #ccc;
        }
        
        .status-indicator.active {
            background-color: #34a853;
            box-shadow: 0 0 0 3px rgba(52, 168, 83, 0.2);
        }
        
        .status-text {
            font-size: 14px;
            color: #666;
            margin-top: 8px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        p {
            color: #666;
            margin-bottom: 20px;
        }
        
        .recording-indicator {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            align-items: center;
            background-color: rgba(0,0,0,0.6);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .recording-indicator.active {
            opacity: 1;
        }
        
        .recording-dot {
            width: 12px;
            height: 12px;
            background-color: #ea4335;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .settings-panel {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        
        .settings-label {
            min-width: 120px;
            margin-right: 15px;
            font-weight: bold;
            color: #555;
        }
        
        .settings-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .shape-option {
            width: 40px;
            height: 40px;
            border: 2px solid #ccc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .shape-option:hover {
            transform: scale(1.1);
        }
        
        .shape-option.selected {
            border-color: #4285f4;
            background-color: rgba(66, 133, 244, 0.1);
        }
        
        .shape-circle {
            border-radius: 50%;
        }
        
        .shape-square {
            border-radius: 4px;
        }
        
        .shape-rounded {
            border-radius: 12px;
        }
        
        .shape-hexagon {
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        .size-value {
            min-width: 40px;
            text-align: center;
        }
        
        .border-color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ddd;
            transition: transform 0.2s;
        }
        
        .border-color-option:hover {
            transform: scale(1.1);
        }
        
        .border-color-option.selected {
            border-color: #333;
            transform: scale(1.1);
        }
        
        .quality-option {
            padding: 6px 12px;
            border-radius: 4px;
            background-color: #f0f0f0;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quality-option:hover {
            background-color: #e0e0e0;
        }
        
        .quality-option.selected {
            background-color: #4285f4;
            color: white;
        }
        
        .settings-toggle {
            background-color: #f0f0f0;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        
        .settings-toggle:hover {
            background-color: #e0e0e0;
        }
        
        .settings-toggle i {
            transition: transform 0.3s;
        }
        
        .settings-toggle.open i {
            transform: rotate(180deg);
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <h1>Screen & Camera Recorder</h1>
        <p>Record your screen with your camera as a customizable, movable bubble. Drag the camera bubble to position it anywhere.</p>
        
        <div class="preview">
            <video id="screenPreview" autoplay muted playsinline></video>
            <div id="cameraPreview">
                <video id="cameraVideo" autoplay muted playsinline></video>
            </div>
            <div class="recording-indicator" id="recordingIndicator">
                <div class="recording-dot"></div>
                <span>Recording</span>
            </div>
        </div>
        
        <div class="status-text">
            <span class="status-indicator" id="screenStatus"></span> Screen
            <span class="status-indicator" id="cameraStatus"></span> Camera
        </div>
        
        <button class="settings-toggle" id="settingsToggle">
            <i class="fas fa-cog"></i> Camera Bubble Settings
        </button>
        
        <div class="settings-panel" id="settingsPanel" style="display: none;">
            <div class="settings-row">
                <div class="settings-label">Shape:</div>
                <div class="settings-options">
                    <div class="shape-option shape-circle selected" data-shape="circle" title="Circle">
                        <i class="fas fa-circle"></i>
                    </div>
                    <div class="shape-option shape-square" data-shape="square" title="Square">
                        <i class="fas fa-square"></i>
                    </div>
                    <div class="shape-option shape-rounded" data-shape="rounded" title="Rounded Square">
                        <i class="fas fa-square"></i>
                    </div>
                    <div class="shape-option shape-hexagon" data-shape="hexagon" title="Hexagon">
                        <i class="fas fa-hexagon"></i>
                    </div>
                </div>
            </div>
            
            <div class="settings-row">
                <div class="settings-label">Size:</div>
                <div class="settings-options">
                    <input type="range" id="sizeSlider" min="100" max="300" value="150" step="10">
                    <span class="size-value" id="sizeValue">150px</span>
                </div>
            </div>
            
            <div class="settings-row">
                <div class="settings-label">Border Color:</div>
                <div class="settings-options">
                    <div class="border-color-option selected" style="background-color: #ffffff;" data-color="#ffffff"></div>
                    <div class="border-color-option" style="background-color: #ff5252;" data-color="#ff5252"></div>
                    <div class="border-color-option" style="background-color: #4caf50;" data-color="#4caf50"></div>
                    <div class="border-color-option" style="background-color: #2196f3;" data-color="#2196f3"></div>
                    <div class="border-color-option" style="background-color: #ff9800;" data-color="#ff9800"></div>
                    <div class="border-color-option" style="background-color: #9c27b0;" data-color="#9c27b0"></div>
                </div>
            </div>
            
            <div class="settings-row">
                <div class="settings-label">Recording Quality:</div>
                <div class="settings-options">
                    <div class="quality-option" data-bitrate="1500000">Standard</div>
                    <div class="quality-option selected" data-bitrate="3000000">High</div>
                    <div class="quality-option" data-bitrate="6000000">Ultra</div>
                </div>
            </div>
            
            <div class="settings-row">
                <div class="settings-label">Frame Rate:</div>
                <div class="settings-options">
                    <div class="quality-option" data-fps="24">24 fps</div>
                    <div class="quality-option selected" data-fps="30">30 fps</div>
                    <div class="quality-option" data-fps="60">60 fps</div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button id="startButton">1. Select Screen</button>
            <button id="cameraButton" disabled>2. Enable Camera</button>
            <button id="recordButton" disabled>3. Start Recording</button>
            <button id="stopButton" disabled>Stop Recording</button>
        </div>
        
        <div id="message" class="message"></div>
        
        <div id="downloadContainer">
            <h3>Recording Complete</h3>
            <video id="downloadVideo" controls playsinline></video>
            <div class="controls">
                <button id="downloadButton">Download Recording</button>
                <button id="newRecordingButton">New Recording</button>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const startButton = document.getElementById('startButton');
        const cameraButton = document.getElementById('cameraButton');
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const screenPreview = document.getElementById('screenPreview');
        const cameraVideo = document.getElementById('cameraVideo');
        const cameraPreview = document.getElementById('cameraPreview');
        const message = document.getElementById('message');
        const downloadContainer = document.getElementById('downloadContainer');
        const downloadVideo = document.getElementById('downloadVideo');
        const downloadButton = document.getElementById('downloadButton');
        const newRecordingButton = document.getElementById('newRecordingButton');
        const screenStatus = document.getElementById('screenStatus');
        const cameraStatus = document.getElementById('cameraStatus');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const settingsToggle = document.getElementById('settingsToggle');
        const settingsPanel = document.getElementById('settingsPanel');
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');
        
        // State variables
        let screenStream = null;
        let cameraStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let compositeStream = null;
        let animationFrameId = null;
        let selectedShape = 'circle';
        let selectedBorderColor = '#ffffff';
        let selectedBitrate = 3000000;
        let selectedFps = 30;
        let offscreenCanvas = null;
        let offscreenCtx = null;
        
        // Initialize camera position if not set
        if (!cameraPreview.style.top) {
            cameraPreview.style.top = '20px';
            cameraPreview.style.right = '20px';
        }
        
        // Settings panel toggle
        settingsToggle.addEventListener('click', () => {
            const isOpen = settingsPanel.style.display !== 'none';
            settingsPanel.style.display = isOpen ? 'none' : 'block';
            settingsToggle.classList.toggle('open', !isOpen);
        });
        
        // Size slider
        sizeSlider.addEventListener('input', () => {
            const size = sizeSlider.value;
            sizeValue.textContent = `${size}px`;
            cameraPreview.style.width = `${size}px`;
            cameraPreview.style.height = `${size}px`;
        });
        
        // Shape selection
        document.querySelectorAll('.shape-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.shape-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedShape = option.dataset.shape;
                
                // Apply shape to camera preview
                cameraPreview.style.borderRadius = '';
                cameraPreview.style.clipPath = '';
                
                switch(selectedShape) {
                    case 'circle':
                        cameraPreview.style.borderRadius = '50%';
                        break;
                    case 'square':
                        cameraPreview.style.borderRadius = '4px';
                        break;
                    case 'rounded':
                        cameraPreview.style.borderRadius = '12px';
                        break;
                    case 'hexagon':
                        cameraPreview.style.clipPath = 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)';
                        break;
                }
            });
        });
        
        // Border color selection
        document.querySelectorAll('.border-color-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.border-color-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedBorderColor = option.dataset.color;
                cameraPreview.style.borderColor = selectedBorderColor;
            });
        });
        
        // Quality selection
        document.querySelectorAll('.quality-option[data-bitrate]').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.quality-option[data-bitrate]').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedBitrate = parseInt(option.dataset.bitrate);
            });
        });
        
        // Frame rate selection
        document.querySelectorAll('.quality-option[data-fps]').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.quality-option[data-fps]').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedFps = parseInt(option.dataset.fps);
            });
        });
        
        // Make camera bubble draggable
        cameraPreview.addEventListener('mousedown', (e) => {
            isDragging = true;
            cameraPreview.classList.add('dragging');
            const rect = cameraPreview.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const container = document.querySelector('.preview');
            const containerRect = container.getBoundingClientRect();
            
            const left = e.clientX - containerRect.left - dragOffset.x;
            const top = e.clientY - containerRect.top - dragOffset.y;
            
            // Keep within preview bounds
            const maxX = containerRect.width - cameraPreview.offsetWidth;
            const maxY = containerRect.height - cameraPreview.offsetHeight;
            
            cameraPreview.style.left = `${Math.min(Math.max(0, left), maxX)}px`;
            cameraPreview.style.top = `${Math.min(Math.max(0, top), maxY)}px`;
            
            // Remove right positioning when manually positioned
            cameraPreview.style.right = 'auto';
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            cameraPreview.classList.remove('dragging');
        });
        
        // Touch support for mobile devices
        cameraPreview.addEventListener('touchstart', (e) => {
            isDragging = true;
            cameraPreview.classList.add('dragging');
            const rect = cameraPreview.getBoundingClientRect();
            const touch = e.touches[0];
            dragOffset.x = touch.clientX - rect.left;
            dragOffset.y = touch.clientY - rect.top;
            e.preventDefault();
        });
        
        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            
            const container = document.querySelector('.preview');
            const containerRect = container.getBoundingClientRect();
            const touch = e.touches[0];
            
            const left = touch.clientX - containerRect.left - dragOffset.x;
            const top = touch.clientY - containerRect.top - dragOffset.y;
            
            // Keep within preview bounds
            const maxX = containerRect.width - cameraPreview.offsetWidth;
            const maxY = containerRect.height - cameraPreview.offsetHeight;
            
            cameraPreview.style.left = `${Math.min(Math.max(0, left), maxX)}px`;
            cameraPreview.style.top = `${Math.min(Math.max(0, top), maxY)}px`;
            
            // Remove right positioning when manually positioned
            cameraPreview.style.right = 'auto';
        });
        
        document.addEventListener('touchend', () => {
            isDragging = false;
            cameraPreview.classList.remove('dragging');
        });
        
        // Step 1: Select screen to record
        startButton.addEventListener('click', async () => {
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always',
                        displaySurface: 'monitor',
                        logicalSurface: true,
                        frameRate: selectedFps
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    }
                });
                
                screenPreview.srcObject = screenStream;
                showMessage('Screen selected! Now enable your camera.');
                startButton.disabled = true;
                cameraButton.disabled = false;
                screenStatus.classList.add('active');
                
                // Handle user stopping the screen share
                screenStream.getVideoTracks()[0].addEventListener('ended', () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        stopRecording();
                    }
                    screenStatus.classList.remove('active');
                    showMessage('Screen sharing ended.', 'warning');
                    resetApp();
                });
            } catch (error) {
                showMessage(`Error accessing screen: ${error.message}`, 'error');
            }
        });
        
        // Step 2: Enable camera
        cameraButton.addEventListener('click', async () => {
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: selectedFps }
                    },
                    audio: false
                });
                
                cameraVideo.srcObject = cameraStream;
                showMessage('Camera enabled! You can now start recording.');
                cameraButton.disabled = true;
                recordButton.disabled = false;
                cameraStatus.classList.add('active');
            } catch (error) {
                showMessage(`Error accessing camera: ${error.message}`, 'error');
            }
        });
        
        // Step 3: Start recording
        recordButton.addEventListener('click', startRecording);
        
        function startRecording() {
            recordedChunks = [];
            
            // Create an offscreen canvas for better performance
            offscreenCanvas = document.createElement('canvas');
            
            // Get screen dimensions for higher quality recording
            const screenTrack = screenStream.getVideoTracks()[0];
            const trackSettings = screenTrack.getSettings();
            
            // Set canvas to match screen resolution or use a high-quality fallback
            const screenWidth = trackSettings.width || 1920;
            const screenHeight = trackSettings.height || 1080;
            
            // Set canvas size to actual screen resolution for best quality
            offscreenCanvas.width = screenWidth;
            offscreenCanvas.height = screenHeight;
            
            // Use high-performance canvas context
            offscreenCtx = offscreenCanvas.getContext('2d', { 
                alpha: false,
                desynchronized: true,
                willReadFrequently: false
            });
            
            // Apply high-quality rendering
            offscreenCtx.imageSmoothingEnabled = true;
            offscreenCtx.imageSmoothingQuality = 'high';
            
            // Create a stream from the canvas with the selected frame rate
            const canvasStream = offscreenCanvas.captureStream(selectedFps);
            
            // Add audio from screen capture if available
            const audioTracks = screenStream.getAudioTracks();
            if (audioTracks.length > 0) {
                canvasStream.addTrack(audioTracks[0]);
            }
            
            // Store the composite stream
            compositeStream = canvasStream;
            
            // Calculate optimal bitrate based on resolution and framerate
            // Higher resolution and framerate need higher bitrate
            const pixelCount = screenWidth * screenHeight;
            const baselineBitrate = selectedBitrate;
            const optimalBitrate = Math.max(
                baselineBitrate,
                Math.min(12000000, Math.round((pixelCount * selectedFps) / 15000))
            );
            
            // Setup media recorder with optimal quality settings
            const options = { 
                mimeType: 'video/webm;codecs=vp9,opus',
                videoBitsPerSecond: optimalBitrate
            };
            
            console.log(`Recording at ${screenWidth}x${screenHeight}, ${selectedFps}fps, ${Math.round(optimalBitrate/1000000)}Mbps`);
            
            try {
                mediaRecorder = new MediaRecorder(compositeStream, options);
            } catch (e) {
                console.warn("VP9 not supported, trying VP8", e);
                try {
                    options.mimeType = 'video/webm;codecs=vp8,opus';
                    mediaRecorder = new MediaRecorder(compositeStream, options);
                } catch (e2) {
                    console.warn("VP8 not supported, using default codec", e2);
                    mediaRecorder = new MediaRecorder(compositeStream);
                }
            }
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = () => {
                // Create a better quality blob
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const videoURL = URL.createObjectURL(blob);
                
                // Set the video source and show the download container
                downloadVideo.src = videoURL;
                downloadContainer.style.display = 'block';
                
                // Enable download button
                downloadButton.onclick = () => {
                    const a = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    a.download = `screen-recording-${timestamp}.webm`;
                    a.href = videoURL;
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        document.body.removeChild(a);
                    }, 100);
                };
                
                // Stop all tracks
                if (compositeStream) {
                    compositeStream.getTracks().forEach(track => track.stop());
                }
                
                // Cancel animation frame
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
            };
            
            // Start recording with larger timeslice for smoother recording
            mediaRecorder.start(500); // 500ms chunks for better quality
            
            // Show recording indicator
            recordingIndicator.classList.add('active');
            
            // Animation function to draw the composite view
            function drawComposite() {
                // Clear the canvas with black background
                offscreenCtx.fillStyle = '#000000';
                offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                
                // Draw screen video at full resolution
                if (screenStream && screenStream.active) {
                    try {
                        offscreenCtx.drawImage(screenPreview, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
                    } catch (e) {
                        console.error("Error drawing screen:", e);
                    }
                }
                
                // Draw camera based on selected shape
                if (cameraStream && cameraStream.active) {
                    try {
                        const cameraRect = cameraPreview.getBoundingClientRect();
                        const previewRect = document.querySelector('.preview').getBoundingClientRect();
                        
                        // Calculate position relative to the preview container
                        // and scale to match the canvas resolution
                        const scaleX = offscreenCanvas.width / previewRect.width;
                        const scaleY = offscreenCanvas.height / previewRect.height;
                        
                        const relativeLeft = cameraRect.left - previewRect.left;
                        const relativeTop = cameraRect.top - previewRect.top;
                        
                        const x = (relativeLeft + cameraPreview.offsetWidth / 2) * scaleX;
                        const y = (relativeTop + cameraPreview.offsetHeight / 2) * scaleY;
                        const radius = (cameraPreview.offsetWidth / 2) * scaleX;
                        
                        offscreenCtx.save();
                        
                        // Create shape path based on selected shape
                        switch(selectedShape) {
                            case 'circle':
                                offscreenCtx.beginPath();
                                offscreenCtx.arc(x, y, radius, 0, Math.PI * 2, true);
                                offscreenCtx.closePath();
                                break;
                            case 'square':
                                offscreenCtx.beginPath();
                                offscreenCtx.rect(x - radius, y - radius, radius * 2, radius * 2);
                                offscreenCtx.closePath();
                                break;
                            case 'rounded':
                                const cornerRadius = radius * 0.2;
                                offscreenCtx.beginPath();
                                offscreenCtx.moveTo(x - radius + cornerRadius, y - radius);
                                offscreenCtx.lineTo(x + radius - cornerRadius, y - radius);
                                offscreenCtx.arcTo(x + radius, y - radius, x + radius, y - radius + cornerRadius, cornerRadius);
                                offscreenCtx.lineTo(x + radius, y + radius - cornerRadius);
                                offscreenCtx.arcTo(x + radius, y + radius, x + radius - cornerRadius, y + radius, cornerRadius);
                                offscreenCtx.lineTo(x - radius + cornerRadius, y + radius);
                                offscreenCtx.arcTo(x - radius, y + radius, x - radius, y + radius - cornerRadius, cornerRadius);
                                offscreenCtx.lineTo(x - radius, y - radius + cornerRadius);
                                offscreenCtx.arcTo(x - radius, y - radius, x - radius + cornerRadius, y - radius, cornerRadius);
                                offscreenCtx.closePath();
                                break;
                            case 'hexagon':
                                offscreenCtx.beginPath();
                                for (let i = 0; i < 6; i++) {
                                    const angle = (Math.PI / 3) * i;
                                    const hx = x + radius * Math.cos(angle);
                                    const hy = y + radius * Math.sin(angle);
                                    if (i === 0) offscreenCtx.moveTo(hx, hy);
                                    else offscreenCtx.lineTo(hx, hy);
                                }
                                offscreenCtx.closePath();
                                break;
                        }
                        
                        // Clip to the shape
                        offscreenCtx.clip();
                        
                        // Draw the camera video inside the shape - use the actual video element
                        const cameraX = x - radius;
                        const cameraY = y - radius;
                        offscreenCtx.drawImage(cameraVideo, cameraX, cameraY, radius * 2, radius * 2);
                        
                        // Draw a border around the shape
                        offscreenCtx.beginPath();
                        switch(selectedShape) {
                            case 'circle':
                                offscreenCtx.arc(x, y, radius, 0, Math.PI * 2, true);
                                break;
                            case 'square':
                                offscreenCtx.rect(x - radius, y - radius, radius * 2, radius * 2);
                                break;
                            case 'rounded':
                                const cornerRadius = radius * 0.2;
                                offscreenCtx.moveTo(x - radius + cornerRadius, y - radius);
                                offscreenCtx.lineTo(x + radius - cornerRadius, y - radius);
                                offscreenCtx.arcTo(x + radius, y - radius, x + radius, y - radius + cornerRadius, cornerRadius);
                                offscreenCtx.lineTo(x + radius, y + radius - cornerRadius);
                                offscreenCtx.arcTo(x + radius, y + radius, x + radius - cornerRadius, y + radius, cornerRadius);
                                offscreenCtx.lineTo(x - radius + cornerRadius, y + radius);
                                offscreenCtx.arcTo(x - radius, y + radius, x - radius, y + radius - cornerRadius, cornerRadius);
                                offscreenCtx.lineTo(x - radius, y - radius + cornerRadius);
                                offscreenCtx.arcTo(x - radius, y - radius, x - radius + cornerRadius, y - radius, cornerRadius);
                                break;
                            case 'hexagon':
                                for (let i = 0; i < 6; i++) {
                                    const angle = (Math.PI / 3) * i;
                                    const hx = x + radius * Math.cos(angle);
                                    const hy = y + radius * Math.sin(angle);
                                    if (i === 0) offscreenCtx.moveTo(hx, hy);
                                    else offscreenCtx.lineTo(hx, hy);
                                }
                                break;
                        }
                        offscreenCtx.closePath();
                        offscreenCtx.strokeStyle = selectedBorderColor;
                        offscreenCtx.lineWidth = Math.max(3, Math.round(radius / 25)); // Scale border with size
                        offscreenCtx.stroke();
                        offscreenCtx.restore();
                    } catch (e) {
                        console.error("Error drawing camera:", e);
                    }
                }
                
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    animationFrameId = requestAnimationFrame(drawComposite);
                }
            }
            
            // Start the animation
            animationFrameId = requestAnimationFrame(drawComposite);
            
            // Update UI
            recordButton.disabled = true;
            stopButton.disabled = false;
            settingsToggle.disabled = true;
            showMessage('Recording started! Click "Stop Recording" when finished.');
        }
        
        // Stop recording
        stopButton.addEventListener('click', stopRecording);
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                recordingIndicator.classList.remove('active');
                showMessage('Recording stopped. You can download your video below.');
                stopButton.disabled = true;
                settingsToggle.disabled = false;
            }
        }
        
        // New recording button
        newRecordingButton.addEventListener('click', resetApp);
        
        function resetApp() {
            // Reset UI
            downloadContainer.style.display = 'none';
            startButton.disabled = false;
            cameraButton.disabled = true;
            recordButton.disabled = true;
            stopButton.disabled = true;
            settingsToggle.disabled = false;
            screenStatus.classList.remove('active');
            cameraStatus.classList.remove('active');
            recordingIndicator.classList.remove('active');
            
            // Stop all streams
            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
            }
            
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            if (compositeStream) {
                compositeStream.getTracks().forEach(track => track.stop());
                compositeStream = null;
            }
            
            // Cancel animation frame if active
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Clear video sources
            screenPreview.srcObject = null;
            cameraVideo.srcObject = null;
            
            // Clean up canvas
            if (offscreenCanvas) {
                offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                offscreenCanvas = null;
                offscreenCtx = null;
            }
            
            showMessage('Ready for a new recording. Click "Select Screen" to begin.');
        }
        
        // Helper function to show messages
        function showMessage(text, type = 'success') {
            message.textContent = text;
            message.style.display = 'block';
            
            // Reset animation
            message.style.animation = 'none';
            setTimeout(() => {
                message.style.animation = 'fadeIn 0.3s';
            }, 10);
            
            if (type === 'error') {
                message.style.backgroundColor = '#f2dede';
                message.style.color = '#a94442';
                message.style.borderColor = '#ebccd1';
            } else if (type === 'warning') {
                message.style.backgroundColor = '#fcf8e3';
                message.style.color = '#8a6d3b';
                message.style.borderColor = '#faebcc';
            } else {
                message.style.backgroundColor = '#dff0d8';
                message.style.color = '#3c763d';
                message.style.borderColor = '#d6e9c6';
            }
        }
        
        // Initialize
        showMessage('Ready to record. Click "Select Screen" to begin.');
    </script>
</body>
</html>
